# Welcome to Gravity Sandbox

Ever looked at the sky and wondered what would happen if you kept spawning objects in space? If so, this simulation is for you.

Using **Raylib** and **C++**, this simulation models interactions between space objects. Simply drag your mouse and release to spawn new objects with different velocities and directions, then watch how they interact and collide. When objects collide, they merge into a new body through perfectly inelastic collisions â€” all in 2D space.

---

## Technical Overview

This section explains how the simulation works from a math and programming perspective.

### **How to Spawn New Objects**

To spawn a new object, press **Left Click + drag**, then release when ready. A longer drag means higher velocity.

All objects have the same radius (`50`), but their color and mass are random, generated by:

```cpp
Color generateRandomColor(const std::vector<Color> &colors);
int generateRandomMass();
```

---

### **How Objects Interact**

Just like in space, every object in this simulation affects every other object. The effect depends on the objectsâ€™ mass and distance.

To compute the force magnitude that object **B** exerts on object **A**, Newtonâ€™s Law of Universal Gravitation is used:

```
F = G * (m1 * m2) / rÂ²
```

This simulation uses the **acceleration form** of the formula.  
After finding the force magnitude, it calculates the direction between object A and B as a normalized vector, then scales it by the force magnitude to get acceleration.

Repeating this for every object except A gives the total acceleration on A.

```cpp
Vector2 Body::GetAccelerationFrom(const Body& bodyB)
{
    Vector2 dir = Vector2Subtract(bodyB.position, position);
    float r2 = Vector2LengthSqr(dir) + epsilon * epsilon;
    Vector2 dirNorm = Vector2Normalize(dir);
    float forceMag = (G * bodyB.mass) / r2;
    return Vector2Scale(dirNorm, forceMag);
}
```

---

### **Integration Method**

The simulation uses **Verlet Integration** for more accurate calculations without sacrificing speed.  
Formula:

```
x(t + Î”t) = 2x(t) - x(t - Î”t) + a(t) * (Î”t)Â²
```

```cpp
void Body::VerletUpdate(const Vector2 acceleration, float dt)
{
    Vector2 temp = position; // xn
    Vector2 delta = Vector2Subtract(position, prevPosition);
    Vector2 accelTerm = Vector2Scale(acceleration, dt * dt);
    position = Vector2Add(Vector2Add(position, delta), accelTerm);
    prevPosition = temp;
}
```

---

### **Merging Objects**

Collisions are treated as **perfectly inelastic** â€” when two bodies collide, they merge into one.

A collision is detected if the distance between two objects is less than the sum of their radii.

The merged objectâ€™s velocity is calculated as:

```
v' = (m1v1 + m2v2) / (m1 + m2)
```

The merged position is determined by a mass-weighted average. After creating the new object, the two old objects are removed.

```cpp
void Body::mergeBodies(Body &BodyB, std::vector<Body> &bodies,
                       const std::vector<Color> &colors,
                       const int bodyBindex, const int bodyAindex)
{
    Vector2 vel = Vector2Add(Vector2Scale(velocity, mass),
                             Vector2Scale(BodyB.velocity, BodyB.mass));
    float combinedMass = mass + BodyB.mass;
    Vector2 mergedVelocity = Vector2Scale(vel, 1.0f / combinedMass);

    Vector2 pos = Vector2Add(Vector2Scale(position, mass),
                             Vector2Scale(BodyB.position, BodyB.mass));
    Vector2 mergedPosition = Vector2Scale(pos, 1.0f / combinedMass);

    Body newBody;
    newBody.mass = combinedMass;
    newBody.radius = radius + BodyB.radius / 2; 
    newBody.position = mergedPosition;
    newBody.color = MAROON;
    newBody.velocity = mergedVelocity;
    newBody.prevPosition = prevPosition;

    bodies.push_back(newBody);

    if (bodyAindex > bodyBindex) {
        bodies.erase(bodies.begin() + bodyAindex);
        bodies.erase(bodies.begin() + bodyBindex);
    } else {
        bodies.erase(bodies.begin() + bodyBindex);
        bodies.erase(bodies.begin() + bodyAindex);
    }
}
```

---

## ğŸ“ Project Structure

```text
â”œâ”€â”€ build                  # CMake build output
â”œâ”€â”€ include                # Header files
â”‚   â””â”€â”€ Body.hpp
â”œâ”€â”€ src                    # Source code
â”‚   â”œâ”€â”€ main.cpp
â”‚   â””â”€â”€ Body.cpp
â”œâ”€â”€ .gitignore
â”œâ”€â”€ CMakeLists.txt
â””â”€â”€ README.md              # This file
```

---

## âš™ï¸ Build Instructions

### ğŸ“¦ Requirements
- C++17-compatible compiler (e.g., `g++`, `clang++`)
- [CMake](https://cmake.org/download/) (3.10+)

### ğŸ› ï¸ Building
```bash
git clone https://github.com/Indective/Gravity-Sandbox.git
cd Gravity-Sandbox
mkdir build && cd build
cmake ..
make
```

### â–¶ï¸ Running
```bash
./gravity_sandbox
```

---

## ğŸ› ï¸ Tech Stack
- **C++**
- **CMake**
- **Raylib**

---

## ğŸ“„ License
Released under the **MIT License**. See [LICENSE](LICENSE) for details.

---

## ğŸ¤ Contributing
Contributions are welcome! Feel free to open issues or submit pull requests to suggest improvements or new features.
